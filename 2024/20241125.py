#first version generated by Grok 2 beta on 2024 11 25 
#import requests
import json
import requests
from datetime import datetime, timedelta
import pytz

import json

# Load the secrets from the JSON file
with open('Notion_secrets.json', 'r') as file:
    secrets = json.load(file)

NOTION_SECRET_KEY = secrets.get('NOTION_SECRET_KEY')
DATABASE_ID = secrets.get('NOTION_DATABASE_ID')
if not NOTION_SECRET_KEY or not DATABASE_ID:
    raise ValueError("Either NOTION_SECRET or DATABASE_ID is missing from secrets.json")

# Use NOTION_SECRET in your headers
headers = {
    "Authorization": f"Bearer {NOTION_SECRET_KEY}",
    "Content-Type": "application/json",
    "Notion-Version": "2022-06-28"
}

# Add debug prints
print("Headers being sent:", headers)

# Rest of your code...

def fetch_tasks():
    url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"
    payload = {
        'filter': {
            'property': 'Done?',
            'checkbox': {
                'equals': True
            }
        }
    }
    
    # Add debug prints
    print("Payload being sent:", payload)

    response = requests.post(url, json=payload, headers=headers)
    print("Response status:", response.status_code)
    print("Response body:", response.text)
    response.raise_for_status()
    return response.json()['results']

def summarize_tasks(tasks):
    task_summary = {}
    for task in tasks:
        task_date = task['properties'].get('Date', {})
        if task_date.get('date', {}).get('start'):
            date_str = task_date['date']['start']
            date = datetime.fromisoformat(date_str).date()
            task_summary[date] = task_summary.get(date, 0) + 1
    
    return task_summary

def fetch_completed_tasks_by_date(target_date):
    # Get Austin timezone
    austin_tz = pytz.timezone('America/Chicago')
    
    # Convert target_date to Austin timezone if it's not already
    if target_date.tzinfo is None:
        target_date = austin_tz.localize(target_date)
    
    # Create start and end times in Austin timezone
    date_start = target_date.replace(hour=0, minute=0, second=0, microsecond=0)
    date_end = target_date.replace(hour=23, minute=59, second=59, microsecond=999999)
    
    # Convert to ISO format with timezone info
    date_start_iso = date_start.isoformat()
    date_end_iso = date_end.isoformat()
    
    payload = {
        'filter': {
            'and': [
                {
                    'property': 'Done?',
                    'checkbox': {
                        'equals': True
                    }
                },
                {
                    'property': 'Completed Date',
                    'date': {
                        'on_or_after': date_start_iso,
                        'on_or_before': date_end_iso
                    }
                }
            ]
        },
        'page_size': 100
    }
    
    response = requests.post(f"https://api.notion.com/v1/databases/{DATABASE_ID}/query", 
                           json=payload, 
                           headers=headers)
    response.raise_for_status()
    
    tasks = response.json()['results']
    print(f"\nTasks completed on {target_date.strftime('%Y-%m-%d')} (Austin, TX time):")
    for task in tasks:
        try:
            task_name = task['properties']['Task name']['title'][0]['text']['content']
            print(f"- {task_name}")
        except (KeyError, IndexError):
            print("- Unnamed Task")
    
    return len(tasks)

def main():
    austin_tz = pytz.timezone('America/Chicago')
    today = datetime.now(austin_tz)
    yesterday = today - timedelta(days=1)
    day_before = today - timedelta(days=2)
    
    print(f"\nSummary (All times in Austin, TX):")
    print(f"Tasks completed yesterday ({yesterday.strftime('%Y-%m-%d')}): {fetch_completed_tasks_by_date(yesterday)}")
    print(f"Tasks completed day before ({day_before.strftime('%Y-%m-%d')}): {fetch_completed_tasks_by_date(day_before)}")

if __name__ == "__main__":
    main()