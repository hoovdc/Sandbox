#gcal_standalone.py
#This script exports events from your Google Calendar to a CSV file.
#Code originally generated by Cursor using Claude 3.5 Sonnet

import os
import datetime
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import csv
import pytz  # To handle timezone conversion

# If modifying these scopes, delete the file token.json.
SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']

# Function to get the Google Calendar API service
def get_calendar_service():
    creds = None
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file('credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    return build('calendar', 'v3', credentials=creds)

def main():
    service = get_calendar_service()

    # Get the current time in UTC and Central Time for today
    today = datetime.datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0).isoformat() + 'Z'

    print('Getting past events from your calendar...')

    # Prepare CSV file with dynamic naming based on export time
    central = pytz.timezone('US/Central')
    export_time = datetime.datetime.now(central).strftime("%Y%m%d_%H%M")
    csv_filename = f'gcal_export_{export_time}.csv'

    with open(csv_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Date', 'Start Time', 'Event Title', 'Event Duration', 'Event Color'])

        page_token = None
        while True:
            # Fetch the events with pagination support and maxResults set to 2500
            events_result = service.events().list(
                calendarId='primary',
                timeMax=today,  # Only events up until today
                singleEvents=True,
                orderBy='startTime',
                maxResults=2500,  # Increase the maximum number of events per query to 2500
                pageToken=page_token  # Handle pagination
            ).execute()

            events = events_result.get('items', [])

            if not events:
                break  # No more events to process

            for event in events:
                start = event['start'].get('dateTime', event['start'].get('date'))
                end = event['end'].get('dateTime', event['end'].get('date'))

                # Convert start and end times to datetime objects, adjusting to US/Central if needed
                if 'dateTime' in event['start']:
                    start_time = datetime.datetime.fromisoformat(start.replace('Z', '+00:00'))
                    start_time = start_time.astimezone(central)
                    end_time = datetime.datetime.fromisoformat(end.replace('Z', '+00:00'))
                    end_time = end_time.astimezone(central)
                else:
                    # If all-day event (no specific time)
                    start_time = datetime.datetime.strptime(start, '%Y-%m-%d')
                    end_time = datetime.datetime.strptime(end, '%Y-%m-%d')

                # Calculate duration for timed events
                if 'dateTime' in event['start']:
                    duration = end_time - start_time
                else:
                    duration = "All day"

                # Get event color (default to 'default' if not set)
                color_id = event.get('colorId', 'default')

                writer.writerow([
                    start_time.date(),
                    start_time.strftime("%H:%M"),  # Display the start time
                    event['summary'],
                    str(duration),
                    color_id
                ])

            # Check if there is a next page of events
            page_token = events_result.get('nextPageToken')
            if not page_token:
                break  # No more pages to fetch

    print(f'Events exported to {csv_filename}')

if __name__ == '__main__':
    main()